#version 450

#extension GL_EXT_scalar_block_layout : require

layout(local_size_x = 32) in;

layout(std430, binding = 0) readonly buffer IndexBuffer {
    uint indices[];
};
layout(scalar, binding = 1) readonly buffer VertexBuffer {
    vec3 vertices[];
};
layout(std430, binding = 2) writeonly buffer MortonCodes {
    uvec2 morton_codes[];
};

layout(push_constant) uniform PushConstants {
    uint indices_offset;
    uint vertices_offset;
    uint morton_codes_offset;
    uint n_triangles;
};

const float ONE_THIRD = 1.0 / 3.0;

// Expands a 10-bit integer into 30 bits
// by inserting 2 zeros after each bit.
uvec3 expandBits(uvec3 v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

// Calculates a 30-bit Morton code for the
// given 3D point located within the unit cube [0,1].
uint morton3D(vec3 point) {
    uvec3 upoint = uvec3(clamp(point + 512.0, 0.0, 1023.0));
    uvec3 ex = expandBits(upoint);
    return ex.x * 4 + ex.y * 2 + ex.z;
}

void main() {
    uint triangle_id = gl_GlobalInvocationID.x;
    if (triangle_id >= n_triangles) {
        return;
    }
    uint first_index_id = indices_offset + triangle_id * 3;

    uint v0_idx = vertices_offset + indices[first_index_id];
    uint v1_idx = vertices_offset + indices[first_index_id + 1];
    uint v2_idx = vertices_offset + indices[first_index_id + 2];

    vec3 v0 = vertices[v0_idx];
    vec3 v1 = vertices[v1_idx];
    vec3 v2 = vertices[v2_idx];

    vec3 center = (v0 + v1 + v2) * ONE_THIRD;
    uint code = morton3D(center);

    morton_codes[triangle_id] = uvec2(code, triangle_id);
}